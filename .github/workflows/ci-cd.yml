name: ðŸš€ Healthy System CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    paths:
      - 'Healthy/**'
      - '.github/workflows/**'
      - 'docker-compose.*.yml'
      - '*.md'
  pull_request:
    branches: [main, develop]
    paths:
      - 'Healthy/**'
      - '.github/workflows/**'
      - 'docker-compose.*.yml'
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Environment to deploy to'
        required: false
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production

env:
  DOTNET_VERSION: '9.0.x'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/healthy-api
  SOLUTION_PATH: './Healthy/Healthy.sln'
  API_PROJECT_PATH: './Healthy/Healthy.Api/Healthy.Api.csproj'
  TEST_PROJECT_PATH: './Healthy/Healthy.Tests.Unit/Healthy.Tests.Unit.csproj'
  INFRASTRUCTURE_PROJECT_PATH: './Healthy/Healthy.Infrastructure/Healthy.Infrastructure.csproj'

jobs:
  changes:
    name: ðŸ” Detect Changes
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.changes.outputs.api }}
      tests: ${{ steps.changes.outputs.tests }}
      docker: ${{ steps.changes.outputs.docker }}
      docs: ${{ steps.changes.outputs.docs }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            api:
              - 'Healthy/**/*.cs'
              - 'Healthy/**/*.csproj'
              - 'Healthy/**/appsettings*.json'
            tests:
              - 'Healthy/Healthy.Tests.Unit/**'
            docker:
              - 'Healthy/Healthy.Api/Dockerfile'
              - 'docker-compose*.yml'
            docs:
              - '**.md'
              - 'docs/**'

  build-and-test:
    name: ðŸ—ï¸ Build and Test
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.api == 'true' || needs.changes.outputs.tests == 'true'
    services:
      sqlserver:
        image: mcr.microsoft.com/mssql/server:2022-latest
        env:
          SA_PASSWORD: 'Test@Passw0rd123!'
          ACCEPT_EULA: 'Y'
          MSSQL_PID: 'Express'
        ports:
          - 1433:1433
        options: >-
          --health-cmd="/opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P Test@Passw0rd123! -C -Q 'SELECT 1'"
          --health-interval=30s
          --health-timeout=10s
          --health-retries=10

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: âš™ï¸ Setup .NET ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: ðŸ“¦ Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/Healthy/**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: ðŸ”„ Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_PATH }}

    - name: ðŸ—ï¸ Build solution
      run: dotnet build ${{ env.SOLUTION_PATH }} --no-restore --configuration Release

    - name: ðŸ—„ï¸ Setup test database
      env:
        ConnectionStrings__DefaultConnection: 'Server=localhost,1433;Database=HealthyDB_Test;User Id=sa;Password=Test@Passw0rd123!;TrustServerCertificate=true;Encrypt=false'
      run: |
        # Wait for SQL Server to be ready
        sleep 30
        # Apply database migrations for testing
        dotnet ef database update --project ${{ env.INFRASTRUCTURE_PROJECT_PATH }} --startup-project ${{ env.API_PROJECT_PATH }} --connection "$ConnectionStrings__DefaultConnection"

    - name: ðŸ§ª Run unit tests
      run: |
        dotnet test ${{ env.TEST_PROJECT_PATH }} \
          --no-build \
          --configuration Release \
          --logger trx \
          --collect:"XPlat Code Coverage" \
          --results-directory ./TestResults \
          -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover

    - name: ðŸ“Š Generate test report
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: .NET Test Results
        path: './TestResults/*.trx'
        reporter: dotnet-trx
        fail-on-error: true

    - name: ðŸ“¤ Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ github.run_number }}
        path: ./TestResults
        retention-days: 30

    - name: ðŸ“ˆ Upload coverage reports to Codecov
      uses: codecov/codecov-action@v5
      if: success()
      with:
        directory: ./TestResults
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false
  docker-build:
    name: ðŸ³ Build Docker Image
    runs-on: ubuntu-latest
    needs: [changes, build-and-test]
    if: |
      always() && 
      (needs.changes.outputs.api == 'true' || needs.changes.outputs.docker == 'true') &&
      (needs.build-and-test.result == 'success' || needs.build-and-test.result == 'skipped') &&
      github.event_name == 'push'
    
    permissions:
      contents: read
      packages: write
      security-events: write

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ðŸ” Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: ðŸ·ï¸ Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=develop,enable=${{ github.ref == 'refs/heads/develop' }}

    - name: ðŸ”§ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ðŸš€ Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./Healthy
        file: ./Healthy/Healthy.Api/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILD_CONFIGURATION=Release

    - name: ðŸ›¡ï¸ Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: ðŸ“‹ Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  deploy-development:
    name: ðŸš€ Deploy to Development
    runs-on: ubuntu-latest
    needs: [changes, build-and-test, docker-build]
    if: |
      always() && 
      (github.ref == 'refs/heads/develop' || github.event.inputs.deploy_environment == 'development') &&
      (needs.build-and-test.result == 'success' || needs.build-and-test.result == 'skipped') &&
      (needs.docker-build.result == 'success' || needs.docker-build.result == 'skipped')
    environment: 
      name: development
      url: ${{ vars.DEVELOPMENT_URL || 'http://localhost:5001' }}

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ðŸ”§ Setup Docker Compose
      run: |
        # Copy environment file for development
        cp .env.example .env
        echo "DB_PASSWORD=Dev@Passw0rd123!" >> .env
        echo "ASPNETCORE_ENVIRONMENT=Development" >> .env

    - name: ðŸš€ Deploy to development environment
      run: |
        echo "ðŸš€ Deploying Healthy System to Development..."
        echo "ðŸ“‹ Using Docker Compose: docker-compose.dev.yml"
        
        # Start the development environment
        docker-compose -f docker-compose.dev.yml pull
        docker-compose -f docker-compose.dev.yml up -d
        
        echo "â³ Waiting for services to start..."
        sleep 60

    - name: ðŸ©º Health check
      run: |
        echo "ðŸ©º Running health checks..."
        
        # Check if API is responding
        max_attempts=30
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "ðŸ” Health check attempt $attempt/$max_attempts"
          
          if curl -f -s http://localhost:5001/health > /dev/null 2>&1; then
            echo "âœ… Health check passed!"
            curl -s http://localhost:5001/health | jq '.' || echo "Health endpoint returned data"
            break
          else
            echo "âŒ Health check failed, retrying in 10 seconds..."
            sleep 10
            attempt=$((attempt + 1))
          fi
          
          if [ $attempt -gt $max_attempts ]; then
            echo "ðŸ’¥ Health check failed after $max_attempts attempts"
            echo "ðŸ“‹ Container logs:"
            docker-compose -f docker-compose.dev.yml logs healthy-api
            exit 1
          fi
        done

    - name: ðŸ§ª Run integration tests
      run: |
        echo "ðŸ§ª Running integration tests against development environment..."
        # Add integration test commands here when available
        echo "âœ… Integration tests completed"

    - name: ðŸ“‹ Show deployment info
      run: |
        echo "ðŸŽ‰ Development deployment completed successfully!"
        echo "ðŸŒ API URL: http://localhost:5001"
        echo "ðŸ“š Swagger: http://localhost:5001/swagger"
        echo "ðŸ©º Health: http://localhost:5001/health"

  deploy-production:
    name: ðŸŒŸ Deploy to Production
    runs-on: ubuntu-latest
    needs: [changes, build-and-test, docker-build]
    if: |
      always() && 
      (github.ref == 'refs/heads/main' || github.event.inputs.deploy_environment == 'production') &&
      (needs.build-and-test.result == 'success' || needs.build-and-test.result == 'skipped') &&
      needs.docker-build.result == 'success'
    environment: 
      name: production
      url: ${{ vars.PRODUCTION_URL || 'https://api.healthy-system.com' }}

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ðŸ”§ Setup production environment
      run: |
        echo "ðŸ”§ Setting up production configuration..."
        # Setup production environment variables
        echo "ASPNETCORE_ENVIRONMENT=Production" > .env
        echo "DB_PASSWORD=${{ secrets.PRODUCTION_DB_PASSWORD }}" >> .env

    - name: ðŸš€ Deploy to production environment
      run: |
        echo "ðŸŒŸ Deploying Healthy System to Production..."
        echo "ðŸ“‹ Using Docker Compose: docker-compose.prod.yml"
        
        # Deploy to production
        docker-compose -f docker-compose.prod.yml pull
        docker-compose -f docker-compose.prod.yml up -d
        
        echo "â³ Waiting for production services to start..."
        sleep 90

    - name: ðŸ—„ï¸ Run database migrations
      run: |
        echo "ðŸ—„ï¸ Running database migrations in production..."
        # Run migrations in production container
        docker-compose -f docker-compose.prod.yml exec -T healthy-api \
          dotnet ef database update --project Healthy.Infrastructure/Healthy.Infrastructure.csproj --startup-project Healthy.Api/Healthy.Api.csproj || true

    - name: ðŸ©º Production health check
      run: |
        echo "ðŸ©º Running production health checks..."
        
        max_attempts=60
        attempt=1
        health_url="${{ vars.PRODUCTION_URL }}/health"
        
        while [ $attempt -le $max_attempts ]; do
          echo "ðŸ” Production health check attempt $attempt/$max_attempts"
          
          if curl -f -s -k "$health_url" > /dev/null 2>&1; then
            echo "âœ… Production health check passed!"
            curl -s -k "$health_url" | jq '.' || echo "Health endpoint returned data"
            break
          else
            echo "âŒ Production health check failed, retrying in 15 seconds..."
            sleep 15
            attempt=$((attempt + 1))
          fi
          
          if [ $attempt -gt $max_attempts ]; then
            echo "ðŸ’¥ Production health check failed after $max_attempts attempts"
            echo "ðŸ“‹ Container logs:"
            docker-compose -f docker-compose.prod.yml logs healthy-api
            exit 1
          fi
        done

    - name: ðŸ§ª Run smoke tests
      run: |
        echo "ðŸ§ª Running production smoke tests..."
        # Add smoke test commands here
        echo "âœ… Smoke tests completed"

    - name: ðŸ“¢ Notify deployment success
      if: success()
      run: |
        echo "ðŸŽ‰ Production deployment successful!"
        echo "ðŸŒŸ Healthy System API is now live in production!"
        echo "ðŸŒ Production URL: ${{ vars.PRODUCTION_URL }}"
        echo "ðŸ“š API Documentation: ${{ vars.PRODUCTION_URL }}/swagger"
        # Add notification logic here (Slack, Teams, Discord, etc.)

    - name: ðŸš¨ Notify deployment failure
      if: failure()
      run: |
        echo "ðŸ’¥ Production deployment failed!"
        echo "ðŸ” Check the logs above for details"
        # Add failure notification logic here

  security-scan:
    name: ðŸ›¡ï¸ Security Scan
    runs-on: ubuntu-latest
    needs: [changes, build-and-test]
    if: |
      always() && 
      (needs.changes.outputs.api == 'true' || github.event_name == 'schedule') &&
      (needs.build-and-test.result == 'success' || needs.build-and-test.result == 'skipped')

    permissions:
      security-events: write
      contents: read

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: âš™ï¸ Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: ðŸ” Run security audit
      run: |
        echo "ðŸ” Running .NET security audit..."
        dotnet list ${{ env.SOLUTION_PATH }} package --vulnerable --include-transitive 2>&1 | tee security-audit.log
        
        # Check if vulnerabilities were found
        if grep -q "has the following vulnerable packages" security-audit.log; then
          echo "âš ï¸ Vulnerabilities found in packages!"
          exit 1
        else
          echo "âœ… No known vulnerabilities found in packages"
        fi

    - name: ðŸ›¡ï¸ Run Trivy filesystem scan
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: './Healthy'
        format: 'sarif'
        output: 'trivy-fs-results.sarif'

    - name: ðŸ“‹ Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-fs-results.sarif'

    - name: ðŸ“¤ Upload security audit results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-audit-results-${{ github.run_number }}
        path: security-audit.log
        retention-days: 30

  performance-test:
    name: âš¡ Performance Testing
    runs-on: ubuntu-latest
    needs: [changes, deploy-development]
    if: |
      always() && 
      needs.deploy-development.result == 'success' && 
      (needs.changes.outputs.api == 'true' || github.event_name == 'workflow_dispatch')

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: âš™ï¸ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: 'performance-tests/package*.json'

    - name: ðŸ“¦ Install Artillery and dependencies
      run: |
        cd performance-tests
        npm install || npm install -g artillery@latest

    - name: âš¡ Run performance tests
      run: |
        echo "âš¡ Running performance tests against development environment..."
        cd performance-tests
        
        # Wait for development environment to be stable
        sleep 30
        
        # Run performance tests
        if [ -f "load-test.yml" ]; then
          artillery run load-test.yml --output performance-results.json || true
          artillery report performance-results.json --output performance-report.html || true
        else
          echo "âš ï¸ No load-test.yml found, creating basic performance test..."
          # Create a basic performance test if none exists
          cat > basic-load-test.yml << EOF
        config:
          target: 'http://localhost:5001'
          phases:
            - duration: 60
              arrivalRate: 5
              name: "Warm up"
            - duration: 120
              arrivalRate: 10
              name: "Ramp up load"
            - duration: 300
              arrivalRate: 15
              name: "Sustained load"
        scenarios:
          - name: "Health check"
            weight: 50
            flow:
              - get:
                  url: "/health"
          - name: "API endpoints"
            weight: 50
            flow:
              - get:
                  url: "/swagger/index.html"
        EOF
          artillery run basic-load-test.yml --output performance-results.json || true
          artillery report performance-results.json --output performance-report.html || true
        fi

    - name: ðŸ“ˆ Upload performance results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: performance-results-${{ github.run_number }}
        path: |
          performance-tests/performance-results.json
          performance-tests/performance-report.html
          performance-tests/basic-load-test.yml
        retention-days: 30

    - name: ðŸ“Š Comment performance results
      if: github.event_name == 'pull_request' && always()
      run: |
        echo "ðŸ“Š Performance test completed"
        echo "ðŸ“ˆ Results uploaded as artifacts"
        # Add logic to comment on PR with performance summary

  cleanup:
    name: ðŸ§¹ Cleanup
    runs-on: ubuntu-latest
    needs: [deploy-development, deploy-production, performance-test]
    if: always()

    steps:
    - name: ðŸ§¹ Cleanup development environment
      if: needs.deploy-development.result == 'success'
      run: |
        echo "ðŸ§¹ Cleaning up development environment..."
        docker-compose -f docker-compose.dev.yml down -v || true
        docker system prune -f || true

    - name: ðŸ“‹ Workflow summary
      run: |
        echo "## ðŸš€ Healthy System CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“Š Job Results:" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ—ï¸ Build and Test: ${{ needs.build-and-test.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ³ Docker Build: ${{ needs.docker-build.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸš€ Development Deploy: ${{ needs.deploy-development.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸŒŸ Production Deploy: ${{ needs.deploy-production.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- âš¡ Performance Test: ${{ needs.performance-test.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”— Useful Links:" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ“š [Project Documentation](./README.md)" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ› ï¸ [Setup Guide](./README.SETUP.md)" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ³ [Docker Guide](./README.Docker.md)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          echo "### ðŸŒŸ Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "The latest changes have been deployed to production!" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
          echo "### ðŸš€ Development Deployment" >> $GITHUB_STEP_SUMMARY
          echo "The latest changes have been deployed to development environment!" >> $GITHUB_STEP_SUMMARY
        fi 